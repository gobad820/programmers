# 동적 계획법

> "중복의 재탕"

## DP의 조건

1. 참조 투명성을 가짐
   ```C++
    int c = 0;
    int add(int a, int b){
        return a + b;
    }
   ```
2. 최적 부분 구조

- 하위 문제를 이용해 결과적 최상위 문제를 해결할 수 있음을 의미
- e.g. 피보나치 수열

3. 겹치는 부분 문제

- 하위 문제의 해를 저장해두고 재사용할 수 있는 구조임을 의미

4. DAG(directed acyclic graph) 구조

- 비사이클 방향 그래프 구조여야 함
- 코딩 테스트에서는 보통 DAG가 충족된 상태로 출제되는 경향이 있음.
- 다만 알고리즘 대회에서는 cycle이 있을 수도 있으므로 이를 해제 후 문제 풀이를 시작

### 정리

신경써야 할 부분은 Optimal structure와 Overlapping Subproblems를 신경써야 한다.
하지만 이를 코테에서 신경 쓰고 문제 풀이에 들어갈 수 있는가?
현실적으로는 어렵다.
아래의 순서에 따라 문제 풀이에 들어가자.

1. 완탐으로 시작 -> 경우의 수가 너무 많다면(10억 이상)
2. Memoization을 이용
   - 배열 크기가 100만 정도 => DP
   - 배열 크기가 1억 이상 => 그리디

---

## DP의 의미

**DP = 완전탐색 + 메모이제이션**

> DP의 점화식을 구하는 것은 매우 어려울 수 있다.

완전 탐색을 풀드시 모든 경우의 수를 생각하고 그 경우의 수를 메모이제이션 해보는 접근이 수월하다.

1. 어떠한 idx에서 모든 경우의 수를 생각
2. 완탐하는 구조를 생션(사실 이게 점화식 구조를 띄게 된다.)
3. 메모이제이션

### 메모이제이션

## DP의 구조

- 기저사례
- 메모이제이션
- 초기화
- 로직

### Top Down
- 재귀 함수를 이용하여 직관적임
- 오버헤드가 커짐
- 꼭 필요한 DP만을 생성함
- 속도가 느림 


### Bottom Up
- 반복문, 재귀적이지 않아서 오버헤드가 작음
- 모든 DP를 다 생성하게 됨
- 속도가 빠름


## 경우의 수를 푸는 DP

> "그냥 다 더한다고 생각"

경우의 수는 `long long` 타입으로 return값 설정
 
